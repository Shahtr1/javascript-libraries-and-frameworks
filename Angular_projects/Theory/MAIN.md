Q. What is DOM?
A. The Document Object Model (DOM) is a programming interface for HTML(HyperText Markup Language) and XML(Extensible markup language) documents. It defines the logical structure of documents and the way a document is accessed and manipulated.

Q. Why DOM is required?
A. HTML is used to structure the web pages and Javascript is used to add behavior to our web pages. When an HTML file is loaded into the browser, the javascript can not understand the HTML document directly.
So, a corresponding document is created(DOM). DOM is basically the representation of the same HTML document but in a different format with the use of objects.
Javascript interprets DOM easily i.e javascript can not understand the tags(<h1>H</h1>) in HTML document but can understand object h1 in DOM. Now, Javascript can access each of the objects (h1, p, etc) by using different functions.

Q. What is Window Object?
A. Window Object is object of the browser which is always at top of the hierarchy. It is like an API that is used to set and access all the properties and methods of the browser. It is automatically created by the browser.

Q. What is Document Object?
A. Document object: When an HTML document is loaded into a window, it becomes a document object. The ‘document’ object has various properties that refer to other objects which allow access to and modification of the content of the web page. If there is a need to access any element in an HTML page, we always start with accessing the ‘document’ object. Document object is property of window object.

Q. What are types of frameworks?
A. There are:

1. Configuration-over-convention frameworks

   - Easy to learn
   - Freedom to structure
   - Needs additional libraries to fill in missing features
   - Extendable

   E.g.,
   React & Vue

2. Convention-over-configuration frameworks

   - Structure straight out of the box
   - Provides solutions for common problems
   - Larger learning curve
   - Not meant for small apps

   E.g.,
   Angular

Q. What is Angular CLI?
A. It is a tool that manages other tools.

- Webpack
- Babel
- TypeScript
- SASS
- Other

CLI handles the configuration for these tools
The purpose of running our code through these tools is to produce a bundle.
The bundle has code that is optimised for production.
So, CLI is a utility tool for managing projects

Q. Why server?
A. It is for development purposes not suitable for production.
Server is optional, we can open files directly on browser.
Browser impose restrictions over applications opened directly on the browser,w e wont be able to make HTTP requests, Upload files. Angular provides us with server.
It can monitor our files for changes.

- ng serve

some recommend ( npm start ), both are same

localhost is a special domain that points to your machine, brower will send the request to pur machine where angular's development server intercepts the request and send back the page

port is like a door to the house

Q. What are decorators in Javascript?
A. They are functions for extending business logic or adding metadata

## Structure explanation

- .editorconfig:
  Its for teams.
  As everyone can use different editors.
  These file can override their settings

- angular.json
  It configures the workspace for our project
  We can change how angular builds our project

- src directory
  cli compiles clode inside this directory

- main.ts
  Its the main file
  load angular code in main entry file.

  What is compilation?
  The process of transforming code into machine code (not always true)
  When do we compile code?
  we compile ts to js, but when?
  There are two compilation strategies:

  1.  Just In Time
      Compile code when needed, when files are downloaded in browser, then browser will compile it
      The server will compile our ts code, then browser will download our code and also angular compiler.
      The browser will have template, services and modules now.
      Browser dont know what they are.
      Angular needs to take the time to help the browser understand these features.
      After compilation is completed browser can be finally able to run our app.

      - The Angular compiler in JIT mode processes and interprets the JavaScript code generated by the development server to create the appropriate runtime constructs that make up your application. It does this by analyzing the source code of your application, generating a set of runtime constructs, and handing them over to the Angular runtime environment to use.

      - When the application is compiled on the server, it is optimized for the specific browser that is being used to access the application. This means that the compiled code can take advantage of browser-specific features and optimizations that may not be available or effective if the code is compiled in the browser itself.

      - By compiling the application on the server, the browser can download and execute a smaller and more optimized set of JavaScript code, which can significantly improve the startup time and overall performance of the application.

      - catchs errors on the browser

  2.  Ahead Of Time
      Compile code on the server, only browser downloads the code and shows it
      CLI will compile our ts into js. it will then move on compiling templates, services and modules.
      after compilation is completed the browser downloads it and shows them directly.

      - catchs errors on the server

      - recommeded to use this always

---

Before we load angular, it needs a platform to run on
a platform means an environment the angular will run on
before we initialise an app we need to provide a platform
The job of platform is to help angular understand the environments

Angular provides two platforms
platformBrowserDynamic (JIT) and platformBrowser(AOT)

we will use platformBrowserDynamic and angular recommends it
by default CLI assumes the strategy is AOT,
if it finds platformBrowserDynamic function it will override the behaviour of this function
the inner mechanics of this function is swapped to support AOT compilation
JIT compilation is dropped
The angular team recommends this function if you ever decide to switch to JIT compilation

When you use platformBrowserDynamic, it creates a Compiler instance at runtime,
which is responsible for compiling and instantiating modules dynamically.
This allows you to load additional modules at runtime, beyond what was initially loaded with the main application.

The platformBrowserDynamic returns a platform reference, it has functions for initialising our app
the platform is the browser
after calling platformBrowserDynamic function we will call bootstrapModule
The job of module is to glue our app together
The CLI has provided us to build everything together, app.module.ts
we pass it to bootstrapModule function, and it will initiate our app in the browser, it will then return a Promise
and we should check if there are any errors in app

Change detection runs twice when an app is initialized
It spots the difference
If the app outputs different results, if our data doesnt change then app shouldnt change either.
This issue can be helpful for debugging, its rare to experience this issue.
we should turn off this behaviour.
By default its enabled, by changing "optimization", to true angular will not run change detection twice, by default its true

---

App module

CLI has create app.module.ts for us
we are initializing our app with this module in main.ts
Be sure the letters A and M are capitalized, main.ts is expecting this name
we need to run angular in browser so we need to import it

Components are essential.

- Angular makes it easy to teach new tags to the browser
- The name of tag should be valid css selectors, and we should not override the tags

---

Difference between Expressions & String interpolation

- Expressions are the code inside the curly brackets
- String interpolation is the process of replacing placeholders into string values

---

Wrap the event with parenthesis, otherwise angular will interpret it as regular attributes
normally events are prefixed with "on", we can safely remove it

---

constructor runs before binding has occured
NgOnInit runs after binding has occured

---

## View vs Content

- The views refer to the component's template
- The content refers to the projected content from the parent component

---

A pipe is a function to transform values, they dont change the original value

temperature | number: '1.0-0'

---

## Direcives

1.  Attribute Directives
    Changes the appearance or behaviour of an element
    ngStyle, ngClass

2.  Structural Directives
    Add or remove elements from the DOM
    - ngTemplate
      Under the hood angular depends on ng-template element for rendering content manipulated by the structural directives.
      It is not recognized by the browser, the purpose is to store one or more elements in

---

## NPX

npx is how we instruct nodejs to run an executable inside bin folder

---

A memory leak us when a variable is not uninitialized

---

## Forms

- Reactive forms: Harder to learn, more flexible, scalable, configured through class
- Template forms: Easier to learn, less flexible, better for small forms, configured through templates

---

## Ng-template vs Ng-container

- ng-container: Content is always rendered
- ng-template: Content must be conditionally rendered, we need to add a structural directive to conditionally render it

---

## NgSubmit

It prevents the browser from auto refreshing when the form is submitted

---

## NgModel

Creates a FormControl instance from a domain model and binds it to a form element, exported from FormsModule
can be added to any element that dont have formControl or formControlName
name attribute is like id to the control

Two way binding:
combines the two syntax together
it sets and emit the value

```bash
<input [(ngModel)]="" />
```

is same as

```bash
<input [value]="" (change)="" />
```

Under the hood, template forms use FormGroups and FormControls

## Imperative and Declarative programming

Imperative programming focuses in the HOW wheras declarative programming focuses on the WHAT

- Imperative example:

```bash
  function add(arr){
    let result = 0;
    for (let i = 0; i < arr.length; i++){
      result += arr[i]
    }
    return result;
  }
```

- Declarative example:

```bash
  function add(arr){
    return arr.reduce((prev, current) => prev + current, 0)
  }
```

## ng add

its similar to npm install command.
npm will just install the package and update the package file and thats it
ng or Angular cli will search for installation instructions inside the package and executes it, it helps us integrate application with our project

## What are web tokens?

- Encoded strings for storing data
- Digitally signed

## History API

history.pushState(null, null, 'Pizza')
the path will be updated and page wont be refreshed
the push state has added anew url to the history
we can leverage this to navigate around the app
the history api only modifies the url, it doesnt change the document, this task is left for us to handle
Angular routing module uses history aoi to swap components and monitor it

## routerLinkActive

It performs a partial match. We can override it my providing options (routerLinkActiveOptions)

## RouterModule

we have two functions for registering routes

- RouterModule.forRoot(routes)
  registers a service called router

- RouterModule.forChild(routes)
  it doesnt as router has been already registered, this is to create routes without registering another instance of routing object

## nullish coalescing (??)

a logical operator that returns its right-hand side operand when its left-hand side operand is null or undefined , and otherwise returns its left-hand side operand.

## route parameters

It is placeholder for any value like
clip/:id

- Problem
  When we are redirecting to same page, it dont destroy the component, but we need new route parameter, so how?
  we replace this

  ```bash
  this.route.snapshot.params.id
  ```

  with
  observable

  ```bash
  this.route.params.subscribe((params: Params) => {
      this.id = params.id;
    });
  ```

## Query Parameters

we use it to filter and sort through data

## Mime Types

- A label to identify the type of data in a file
- Broken into two parts. The type and subtype separated by a slash

## Testing
